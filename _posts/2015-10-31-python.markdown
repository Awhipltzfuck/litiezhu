---
layout: post
title:  "Context Manager"
date:   2015-10-31 22:21:49
categories: 深入python
tags: 深入python
---
Python中的上下文管理器
1. 上下文管理器是什么？


有时候我们需要在当程序在语句块中运行时保持某种状态，并且在离开语句块后结束这种状态。

所以，事实上上下文管理器的任务是 – 代码块执行前准备，代码块执行后收拾。

上下文管理器是在Python2.5加入的功能，它能够让你的代码可读性更强并且错误更少。

 

2. 如何使用上下文管理器？

看代码是最好的学习方式，来看看我们通常是如何打开一个文件并写入”Hello World”？

writer = open(filename, mode)
writer.write("nidaye")
writer.close()

为什么还需要上下文管理器？但是我们忽略了一个很小但是很重要的细节：如果我们没有机会到达行关闭文件，那会怎样？

举个例子，磁盘已满，因此我们在第4行尝试写入文件时就会抛出异常，而第6行则根本没有机会执行。

当然，我们可以使用try-finally语句块来进行包装：


writer = open(filename, mode)
try:
    writer.write("nidaye")
finally:
    writer.close()

finally语句块中的代码无论try语句块中发生了什么都会执行。因此可以保证文件一定会关闭。这么做有什么问题么？当然没有，但当我们进行一些比写入“Hello world”更复杂的事情时，try-finally语句就会变得丑陋无比。例如我们要打开两个文件，一个读一个写，两个文件之间进行拷贝操作，那么通过with语句能够保证两者能够同时被关闭。

OK，让我们把事情分解一下：

首先，创建一个名为“writer”的文件变量。

然后，对writer执行一些操作。

最后，关闭writer。

这样是不是优雅多了？


with MyWithOpen("hhhh", "w") as my:
    my.write("nidaye")
    raise Exception

让我们深入一点，“with”是一个新关键词，并且总是伴随着上下文管理器出现。“open(filename, mode)”曾经在之前的代码中出现。“as”是另一个关键词，它指代了从“open”函数返回的内容，并且把它赋值给了一个新的变量。“writer”是一个新的变量名。

2-3行，缩进开启一个新的代码块。在这个代码块中，我们能够对writer做任意操作。这样我们就使用了“open”上下文管理器，它保证我们的代码既优雅又安全。它出色的完成了try-finally的任务。

open函数既能够当做一个简单的函数使用，又能够作为上下文管理器。这是因为open函数返回了一个文件类型(file type)变量，而这个文件类型实现了我们之前用到的write方法，但是想要作为上下文管理器还必须实现一些特殊的方法，我会在接下来的小节中介绍。

3. 自定义上下文管理器

让我们来写一个“open”上下文管理器。

要实现上下文管理器，必须实现两个方法 – 一个负责进入语句块的准备操作，另一个负责离开语句块的善后操作。同时，我们需要两个参数：文件名和打开方式。

Python类包含两个特殊的方法，分别名为：__enter__以及__exit__(双下划线作为前缀及后缀)。

当一个对象被用作上下文管理器时：

__enter__ 方法将在进入代码块前被调用。

__exit__ 方法则在离开代码块之后被调用(即使在代码块中遇到了异常)。


我们如何给一个类传递参数？其实在任何类中，都可以使用__init__方法，在此我们将重写它以接收两个必要参数(filename, mode)。

当我们进入语句块时，将会使用open函数，正如第一个例子中那样。而当我们离开语句块时，将关闭一切在__enter__函数中打开的东西。

以下是我们的代码：

class MyWithOpen(object):
    def __init__(self, filename, mode):
        self.filename = filename
        self.mode = mode

    def __enter__(self):
        print 'enter start'
        self.opendFile = open(self.filename, self.mode)
        return self.opendFile

    def __exit__(self, exc_type, exc_val, exc_tb):
        print exc_type, exc_val, exc_tb, '==w==w'
        self.opendFile.close()
        return True



除此之外，还有一些需要强调的事情：

如何处理异常

我们完全忽视了语句块内部可能出现的问题。

如果语句块内部发生了异常，__exit__方法将被调用，而异常将会被重新抛出(re-raised)。当处理文件写入操作时，大部分时间你肯定不希望隐藏这些异常，所以这是可以的。而对于不希望重新抛出的异常，我们可以让__exit__方法简单的返回True来忽略语句块中发生的所有异常(大部分情况下这都不是明智之举)。

我们可以在异常发生时了解到更多详细的信息，完备的__exit__函数签名应该是这样的：

def __exit__(self, exc_type, exc_val, exc_tb)
这样__exit__函数就能够拿到关于异常的所有信息(异常类型，异常值以及异常追踪信息)，这些信息将帮助异常处理操作。

如果__exit__返回为True,那么会忽略异常，否则会抛出异常

通过上下文管理器，我们控制对象在程序不同区间的特性。上下文管理器(with EXPR as VAR)大致相当于如下流程:

复制代码
# with EXPR as VAR:

VAR = EXPR
VAR = VAR.__enter__()
try:
    BLOCK
finally:
    VAR.__exit__()
复制代码
由于上下文管理器带来的便利，它是一个值得使用的工具。


Python上下文管理器

上下文管理器

在使用Python编程中，可以会经常碰到这种情况：有一个特殊的语句块，在执行这个语句块之前需要先执行一些准备动作；当语句块执行完成后，需要继续执行一些收尾动作。

例如：当需要操作文件或数据库的时候，首先需要获取文件句柄或者数据库连接对象，当执行完相应的操作后，需要执行释放文件句柄或者关闭数据库连接的动作。

又如，当多线程程序需要访问临界资源的时候，线程首先需要获取互斥锁，当执行完成并准备退出临界区的时候，需要释放互斥锁。

对于这些情况，Python中提供了上下文管理器（Context Manager）的概念，可以通过上下文管理器来定义/控制代码块执行前的准备动作，以及执行后的收尾动作。

上下文管理协议

那么在Python中怎么实现一个上下文管理器呢？这里，又要提到两个"魔术方法"，__enter__和__exit__，下面就是关于这两个方法的具体介绍。

__enter__(self) Defines what the context manager should do at the beginning of the block created by the with statement. Note that the return value of __enter__ is bound to the target of the with statement, or the name after the as.
__exit__(self, exception_type, exception_value, traceback) Defines what the context manager should do after its block has been executed (or terminates). It can be used to handle exceptions, perform cleanup, or do something always done immediately after the action in the block. If the block executes successfully, exception_type, exception_value, and traceback will be None. Otherwise, you can choose to handle the exception or let the user handle it; if you want to handle it, make sure __exit__ returns True after all is said and done. If you don't want the exception to be handled by the context manager, just let it happen.
也就是说，当我们需要创建一个上下文管理器类型的时候，就需要实现__enter__和__exit__方法，这对方法就称为上下文管理协议（Context Manager Protocol），定义了一种运行时上下文环境。

with语句

在Python中，可以通过with语句来方便的使用上下文管理器，with语句可以在代码块运行前进入一个运行时上下文（执行__enter__方法），并在代码块结束后退出该上下文（执行__exit__方法）。

with语句的语法如下：

with context_expr [as var]:
    with_suite
context_expr是支持上下文管理协议的对象，也就是上下文管理器对象，负责维护上下文环境
as var是一个可选部分，通过变量方式保存上下文管理器对象
with_suite就是需要放在上下文环境中执行的语句块
在Python的内置类型中，很多类型都是支持上下文管理协议的，例如file，thread.LockType，threading.Lock等等。这里我们就以file类型为例，看看with语句的使用。

with语句简化文件操作

当需要写一个文件的时候，一般都会通过下面的方式。代码中使用了try-finally语句块，即使出现异常，也能保证关闭文件句柄。

复制代码
logger = open("log.txt", "w")
try:
    logger.write('Hello ')
    logger.write('World')
finally:
    logger.close()

print logger.closed    
复制代码
其实，Python的内置file类型是支持上下文管理协议的，可以直接通过内建函数dir()来查看file支持的方法和属性：

复制代码
>>> print dir(file)
['__class__', '__delattr__', '__doc__', '__enter__', '__exit__', '__format__', '
__getattribute__', '__hash__', '__init__', '__iter__', '__new__', '__reduce__',
'__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclass
hook__', 'close', 'closed', 'encoding', 'errors', 'fileno', 'flush', 'isatty', '
mode', 'name', 'newlines', 'next', 'read', 'readinto', 'readline', 'readlines',
'seek', 'softspace', 'tell', 'truncate', 'write', 'writelines', 'xreadlines']
>>>
复制代码
所以，可以通过with语句来简化上面的代码，代码的效果是一样的，但是使用with语句的代码更加的简洁：

with open("log.txt", "w") as logger:
    logger.write('Hello ')
    logger.write('World')
    
print logger.closed    
自定义上下文管理器

对于自定义的类型，可以通过实现__enter__和__exit__方法来实现上下文管理器。

看下面的代码，代码中定义了一个MyTimer类型，这个上下文管理器可以实现代码块的计时功能：

复制代码
import time

class MyTimer(object):
    def __init__(self, verbose = False):
        self.verbose = verbose
        
    def __enter__(self):
        self.start = time.time()
        return self
        
    def __exit__(self, *unused):
        self.end = time.time()
        self.secs = self.end - self.start
        self.msecs = self.secs * 1000
        if self.verbose:
            print "elapsed time: %f ms" %self.msecs
复制代码
下面结合with语句使用这个上下文管理器：

复制代码
def fib(n):
    if n in [1, 2]:
        return 1
    else:
        return fib(n-1) + fib(n-2)
        
with MyTimer(True):
    print fib(30)
复制代码
代码输出结果为：



异常处理和__exit__

在使用上下文管理器中，如果代码块 （with_suite）产生了异常，__exit__方法将被调用，而__exit__方法又会有不同的异常处理方式。

当__exit__方法退出当前运行时上下文时，会并返回一个布尔值，该布尔值表明了"如果代码块 （with_suite）执行中产生了异常，该异常是否须要被忽略"。

1. __exit__返回False，重新抛出(re-raised)异常到上层

修改前面的例子，在MyTimer类型中加入了一个参数"ignoreException"来表示上下文管理器是否会忽略代码块 （with_suite）中产生的异常。

复制代码
import time

class MyTimer(object):
    def __init__(self, verbose = False, ignoreException = False):
        self.verbose = verbose
        self.ignoreException = ignoreException
        
    def __enter__(self):
        self.start = time.time()
        return self
        
    def __exit__(self, *unused):
        self.end = time.time()
        self.secs = self.end - self.start
        self.msecs = self.secs * 1000
        if self.verbose:
            print "elapsed time: %f ms" %self.msecs
        return self.ignoreException
        
try:        
    with MyTimer(True, False):
        raise Exception("Ex4Test")
except Exception, e:
    print "Exception (%s) was caught" %e
else:
    print "No Exception happened"
复制代码
运行这段代码，会得到以下结果，由于__exit__方法返回False，所以代码块 （with_suite）中的异常会被继续抛到上层代码。



2. __exit__返回Ture，代码块 （with_suite）中的异常被忽略

将代码改为__exit__返回为True的情况：

复制代码
try:        
    with MyTimer(True, True):
        raise Exception("Ex4Test")
except Exception, e:
    print "Exception (%s) was caught" %e
else:
    print "No Exception happened"
复制代码
运行结果就变成下面的情况，代码块 （with_suite）中的异常被忽略了，代码继续运行：



一定要小心使用__exit__返回Ture的情况，除非很清楚为什么这么做。

3. 通过__exit__函数完整的签名获取更多异常信息

对于__exit__函数，它的完整签名如下，也就是说通过这个函数可以获得更多异常相关的信息。

__exit__(self, exception_type, exception_value, traceback)
继续修改上面例子中的__exit__函数如下：

复制代码
def __exit__(self, exception_type, exception_value, traceback):
    self.end = time.time()
    self.secs = self.end - self.start
    self.msecs = self.secs * 1000
    if self.verbose:
        print "elapsed time: %f ms" %self.msecs
        
    print "exception_type: ", exception_type
    print "exception_value: ", exception_value
    print "traceback: ", traceback
    
    return self.ignoreException
这次运行结果中，就显示出了更多异常相关的信息了：



总结

本文介绍了Python中的上下文管理器，以及如何结合with语句来使用上下文管理器。

总结一下with 语句的执行流程：

执行context_expr 以获取上下文管理器对象
调用上下文管理器的 __enter__() 方法
如果有 as var 从句，则将 __enter__() 方法的返回值赋给 var
执行代码块 with_suite
调用上下文管理器的 __exit__() 方法，如果 with_suite 产生异常，那么该异常的 type、value 和 traceback 会作为参数传给 __exit__()，否则传三个 None
如果 with_suite 产生异常，并且 __exit__() 的返回值等于 False，那么这个异常将被重新抛出到上层
如果 with_suite 产生异常，兵器 __exit__() 的返回值等于 True，那么这个异常就被忽略，继续执行后面的代码
在很多情况下，with语句可以简化代码，并增加代码的健壮性。



注：程序中大量的文件读写，肯定可以用with；大量的通知第三方和并发锁接口，想不过来！
http://www.cnblogs.com/wilber2013/p/4638967.html／http://blog.jobbole.com/64175/

 
