---
layout: post
title:  "ffg"
date:   2015-11-02 09:53:49
categories: 深入python
tags: 深入python
---
1. 写文件最好是用with，自动替你close文件

2. 如果不手动close文件会怎么样？

3. 有可能当对象的引用计数降为0时，Python会关闭文件，进而垃圾回收机制清理文件对象，导致文件内容被刷入磁盘。（各种python版本不同，而且 PyPy 和 CPython中工作机制的不同有关），还有可能是程序退出时被保存的。

4. 那么至少在非常简单的情形下，你的数据不一定有丢失的危险。然而你还是不能确定数据到底是在文件对象引用结束还是程序退出的时候被保存的。如果你假定因为对文件唯一的引用是一个本地变量所以文件在函数返回时会关闭，那么事实一定会让你感到吃惊。如果你有多个进程或线程同时对一个文件进行写操作，那么你真的要非常小心了。

5. 如果写文件很大，那么可能到4096时自动写入，因为标准IO会全缓冲4096Bytes的数据。当达到这么多数据时才会进行实际的磁盘写入，而系统调用write则是直接写入，不进行缓冲。

6. 标准IO库提供缓冲的目的是尽可能减少使用read和write调用的次数，降低执行IO的时间，它提供三种类型的缓冲：

     全缓冲。在填满标准IO缓冲区4096Bytes后（缓冲区已满）才进行实际IO操作（通过write系统调用，将数据传递到内核高速缓冲区，最终内核将数据写入磁盘），对于磁盘文件通常就是全缓冲，上面的示例就是采用缓冲。

     行缓冲。在输入和输出中遇到换行符时（缓冲区已满）进行实际的IO操作（通过write系统调用，将数据传递到内核高速缓冲区，最终内核将数据写入磁盘），当涉及到一个终端时，通常使用行缓冲。使用最频繁的printf函数就是采用行缓冲，所以感觉不出缓冲的存在。

    不带缓冲。标准IO库不对字符进行缓冲存储。标准出错流stderr通常是不带缓冲的。

　　ISO C要求下列缓冲特征：当且仅当标准输入和标准输出并不涉及交互式设备时，它们才是全缓冲的。
标准出错决不会是全缓冲。

    很多系统默认使用下列类型的缓冲：标准出错是不带缓冲的。如若是涉及终端设备的其它流，则他们是行缓冲的；否则是全缓冲的。


 
