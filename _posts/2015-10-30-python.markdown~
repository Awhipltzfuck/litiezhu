---
layout: post
title:  "基本知识"
date:   2015-11-01 09:53:49
categories: 深入python
tags: 深入python
---
1. 没有3目运算符，不过可以写一行if

2. file也是一种内置类型，可以使用dir(file)查看属性

3. redis.__file__查看模块路径，就可以查看源代码

4. easy_install pip #pip 安装python模块

4. google.protobuf在线安装：

  pip install protobuf


5. pip install pylint

6. pylint非常推荐的静态代码检查工具。

    W: 10, 0: Unused import help (unused-import)<br>
   报告中安装上述的格式生成检查结果，W代表生成的检查级别，级别分为4种：error， warning， refactor， convention；可以根据首字母来对应相应的级别。"10, 0" 代表告警所在源码文件中的行号和列号，可以通过Eclipse中CTRL+L快捷键快速查找所在到问题所在的行。“Unused import help"表述问题的详细信息。”(unused-import)为问题的消息ID信息。

6. 写文件：

1. 写文件最好是用with，自动替你close文件

2. 如果不手动close文件会怎么样？

3. 有可能当对象的引用计数降为0时，Python会关闭文件，进而垃圾回收机制清理文件对象，导致文件内容被刷入磁盘。（各种python版本不同，而且 PyPy 和 CPython中工作机制的不同有关），还有可能是程序退出时被保存的。

4. 那么至少在非常简单的情形下，你的数据不一定有丢失的危险。然而你还是不能确定数据到底是在文件对象引用结束还是程序退出的时候被保存的。如果你假定因为对文件唯一的引用是一个本地变量所以文件在函数返回时会关闭，那么事实一定会让你感到吃惊。如果你有多个进程或线程同时对一个文件进行写操作，那么你真的要非常小心了。

5. 如果写文件很大，那么可能到4096时自动写入，因为标准IO会全缓冲4096Bytes的数据。当达到这么多数据时才会进行实际的磁盘写入，而系统调用write则是直接写入，不进行缓冲。

6. 标准IO库提供缓冲的目的是尽可能减少使用read和write调用的次数，降低执行IO的时间，它提供三种类型的缓冲：

     全缓冲。在填满标准IO缓冲区4096Bytes后（缓冲区已满）才进行实际IO操作（通过write系统调用，将数据传递到内核高速缓冲区，最终内核将数据写入磁盘），对于磁盘文件通常就是全缓冲，上面的示例就是采用缓冲。

     行缓冲。在输入和输出中遇到换行符时（缓冲区已满）进行实际的IO操作（通过write系统调用，将数据传递到内核高速缓冲区，最终内核将数据写入磁盘），当涉及到一个终端时，通常使用行缓冲。使用最频繁的printf函数就是采用行缓冲，所以感觉不出缓冲的存在。

    不带缓冲。标准IO库不对字符进行缓冲存储。标准出错流stderr通常是不带缓冲的。

　　ISO C要求下列缓冲特征：当且仅当标准输入和标准输出并不涉及交互式设备时，它们才是全缓冲的。
标准出错决不会是全缓冲。

    很多系统默认使用下列类型的缓冲：标准出错是不带缓冲的。如若是涉及终端设备的其它流，则他们是行缓冲的；否则是全缓冲的。

6. 推导式(Comprehensions)：md5排序，都可以考虑用哈，已经用过一个了！

    列表推导也可能会有一些负面效应，那就是整个列表必须一次性加载于内存之中，这对上面举的例子而言不是问题，甚至扩大若干倍之后也都不是问题。但是总会达到极限，内存总会被用完.针对上面的问题，生成器(Generator)能够很好的解决。生成器表达式不会一次将整个列表加载到内存之中，而是生成一个生成器对象(Generator objector)，所以一次只加载一个列表元素<br>

    生成器表达式同列表推导式有着几乎相同的语法结构，区别在于生成器表达式是被圆括号包围，而不是方括号：除非特殊的原因，应该经常在代码中使用生成器表达式。但除非是面对非常大的列表，否则是不会看出明显区别的。<br>

    num = [1, 4, -5, 10, -7, 2, 3, -1]<br>

    filtered_and_squared = ( x**2 for x in num if x > 0 )<br>


7. zip（已购接口用过）：<br>

alist = ['a1', 'a2', 'a3']<br>
blist = ['1', '2', '3']<br>
for a, b in zip(alist, blist):<br>
    print a, b<br>



注：如果只是浮于表面，只会if else，逻辑处理，简单只是运用，根本不可能看一些python相关源码，django之类的，例如单例／装饰器／描述符／上下文／元类等等，所以必须要深进去！！


 
